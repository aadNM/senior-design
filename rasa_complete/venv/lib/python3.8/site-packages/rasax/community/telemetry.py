import os
import datetime
import hashlib
import logging
import uuid
import asyncio
import urllib.parse
import platform
from multiprocessing.context import BaseContext

import requests
from functools import wraps
from typing import Any, Dict, Optional, Text, TYPE_CHECKING, Union, List, Callable

from rasa.shared.exceptions import RasaException
from sanic import Sanic
from sqlalchemy.orm import Session
import aiohttp

import rasax.community.utils.cli as cli_utils
import rasax.community.database.utils as db_utils
import rasax.community.config as rasa_x_config
import rasax.community.constants as constants
import rasax.community.utils.config as config_utils
import rasax.community.utils.common as common_utils
from rasax.community.services.config_service import (
    ConfigService,
    ConfigKey,
    MissingConfigValue,
    InvalidConfigValue,
)

from rasax.community.version import __version__

if TYPE_CHECKING:
    from multiprocessing import Queue, Process

logger = logging.getLogger(__name__)

SEGMENT_ENDPOINT = "https://api.segment.io/v1/track"
USER_GROUPS_ENDPOINT = os.environ.get(
    "USER_GROUPS_ENDPOINT", "https://assets.rasa.com/functions/rasa-x-user-groups"
)
TELEMETRY_HTTP_TIMEOUT = 2  # Seconds
ENVIRONMENT_LIVE_TIMEOUT = 2  # Seconds
USER_GROUPS_HTTP_TIMEOUT = 5  # Seconds
TELEMETRY_ID = "metrics_id"
TELEMETRY_ID_LENGTH = 64

# If updating or creating a new event, remember to update
# docs/docs/telemetry/events.json as well!
LOCAL_START_EVENT = "Local X Start"
SERVER_START_EVENT = "Server X Start"
MODEL_TRAINED_EVENT = "Model Trained"
MODEL_UPLOADED_EVENT = "Model Uploaded"
MODEL_PROMOTED_EVENT = "Model Promoted"
MODEL_TRAINING_FAILED_EVENT = "Model Training Failed"
MESSAGE_RECEIVED_EVENT = "Message Received"
MESSAGE_ANNOTATED_EVENT = "Message Annotated"
MESSAGE_FLAGGED_EVENT = "Message Flagged"
MESSAGE_TAGGED = "Message Tagged"
STORY_CREATED_EVENT = "Story Created"
E2E_TEST_CREATED_EVENT = "End-to-End Test Created"
STATUS_EVENT = "Status"
REPOSITORY_CREATED_EVENT = "Repository Created"
GIT_CHANGES_PUSHED_EVENT = "Git Changes Pushed"
FEATURE_FLAG_UPDATED_EVENT = "Feature Flag Updated"
CONVERSATION_TAGGED = "Conversation Tagged"
CONVERSATION_REVIEWED = "Conversation Reviewed"
CONVERSATION_SAVED_FOR_LATER = "Conversation Saved For Later"
CONVERSATION_UNDO_REVIEWED = "Undo Conversation Reviewed"
CONVERSATION_UNDO_SAVED_FOR_LATER = "Undo Conversation Saved For Later"
CONVERSATION_DELETED = "Conversation Deleted"
CONVERSATIONS_IMPORTED_EVENT = "Conversations Imported"

MESSAGE_ANNOTATED_CONVERSATIONS = "conversations"
MESSAGE_ANNOTATED_NEW_DATA = "annotate_new_data"
MESSAGE_ANNOTATED_INTERACTIVE_LEARNING = "interactive_learning"

FROM_INTERACTIVE = "interactive"
FROM_STORIES = "stories"

CROSS_VALIDATION_RESULT_REQUESTED = "Rasa Cross-Validation Result Requested"
SCORECARD_RESULT_REQUESTED = "Scorecard Result Requested"

# Telemetry events queue, shared between Rasa X processes
_telemetry_queue = None


def ensure_telemetry_initialized(f: Callable) -> Callable:
    """Function decorator for telemetry functions.

    The decorated function will only run if the telemetry events queue has been
    initialized. Exceptions will be caught and logged.

    Args:
        f: Function to decorate.
    """

    @wraps(f)
    def decorated(*args, **kwargs):
        try:
            if get_events_queue() is not None:
                return f(*args, **kwargs)
        except Exception as e:
            logger.debug(f"Skipping telemetry collection: {e}")

    return decorated


def initialize_global_state(context: BaseContext) -> None:
    """Initialize the global state of the module.

    Args:
        context: The current multiprocessing context.
    """
    # The `events_queue` might already be initialized when started in local mode
    if not get_events_queue():
        set_events_queue(context.Queue())


def get_events_queue() -> Optional["Queue"]:
    """Return the global telemetry events queue.

    Returns:
        The `multiprocessing.Queue` for telemetry events.
    """
    return _telemetry_queue


def set_events_queue(queue: Optional["Queue"]) -> None:
    """Establish the global telemetry events queue for the current process.
    To create new processes that inherit this events queue, use the
    `run_in_process` function.

    Args:
        queue: Object to set as the events queue.
    """
    global _telemetry_queue
    _telemetry_queue = queue


def segment_request_header(write_key: Text) -> Dict[Text, Any]:
    """Use a segment write key to create authentication headers for the segment API."""

    return {
        "Authorization": "Basic {}".format(common_utils.encode_base64(write_key + ":")),
        "Content-Type": "application/json",
    }


def segment_request_payload(
    distinct_id: Text,
    event_name: Text,
    properties: Optional[Dict[Text, Any]] = None,
    context: Optional[Dict[Text, Any]] = None,
) -> Dict[Text, Any]:
    """Compose a valid payload for the segment API."""

    return {
        "userId": distinct_id,
        "event": event_name,
        "properties": properties or {},
        "context": context or {},
    }


def _context_allows_telemetry() -> bool:
    """Check if this Rasa X build is enabled to make requests to external
    services, like Segment or https://rasa.com.

    Returns:
        `True` if external HTTP requests are allowed for this build.
    """
    if not rasa_x_config.telemetry_write_key:
        # If TELEMETRY_WRITE_KEY is empty or `None`, telemetry has not been
        # enabled for this Rasa X build. Telemetry is only enabled for builds
        # that are tagged with a version (e.g. 0.28.0).
        logger.info("Skipping request to external service: telemetry key not set.")
        return False

    if common_utils.in_continuous_integration():
        # Don't make requests to external services during builds.
        logger.info("Skipping request to external service: running in a CI context.")
        return False

    return True


def _send_event(
    distinct_id: Text,
    event_name: Text,
    properties: Optional[Dict[Text, Any]] = None,
    context: Optional[Dict[Text, Any]] = None,
) -> None:
    """Sends the contents of an event to the /track Segment endpoint.
    Documentation: https://segment.com/docs/sources/server/http/

    Do not call this function from outside telemetry.py! This function does not
    check if telemetry is enabled or not.

    Args:
        distinct_id: Unique telemetry ID.
        event_name: Name of the event.
        properties: Values to send along the event.
        context: Context information about the event.
    """
    if not _context_allows_telemetry():
        return

    headers = segment_request_header(rasa_x_config.telemetry_write_key)
    payload = segment_request_payload(distinct_id, event_name, properties, context)

    resp = requests.post(
        SEGMENT_ENDPOINT, headers=headers, json=payload, timeout=TELEMETRY_HTTP_TIMEOUT
    )
    resp.raise_for_status()

    data = resp.json()
    if not data.get("success"):
        raise Exception(f"Got an unsuccessful response from Segment: {data}")


def _with_default_context_fields(
    context: Optional[Dict[Text, Any]] = None,
) -> Dict[Text, Any]:
    """Return a new context dictionary that contains the default field values merged
    with the provided ones. The default fields contain only the OS information for now.

    Args:
        context: Context information about the event.

    Return:
        A new context.
    """

    context = context or {}

    return {"os": {"name": platform.system(), "version": platform.release()}, **context}


def _track_internal(
    event_name: Text,
    properties: Optional[Dict[Text, Any]] = None,
    context: Optional[Dict[Text, Any]] = None,
) -> None:
    """Add a telemetry event to the telemetry events queue.

    Do not call this function from outside telemetry.py! This function does not
    check if telemetry is enabled or not.

    Args:
        event_name: Name of the event.
        properties: Values to send along the event.
        context: Context information about the event.
    """

    queue = get_events_queue()

    if not queue:
        logger.warning("Telemetry queue has not been initialized: can't add event")
        return

    # This event will eventually be picked up by the telemetry queue-consuming
    # process. Note that adding this event to the queue is not blocking, since
    # the queue does not have a maximum capacity defined.
    queue.put(
        {
            "name": event_name,
            "properties": properties,
            "context": _with_default_context_fields(context),
        }
    )


@ensure_telemetry_initialized
def track(
    event_name: Text,
    properties: Optional[Dict[Text, Any]] = None,
    context: Optional[Dict[Text, Any]] = None,
) -> None:
    """Tracks a telemetry event.

    It is OK to use this function from outside telemetry.py, but note that it
    is recommended to create a new track_xyz() function for complex telemetry
    events, or events that are generated from many parts of the Rasa X code.

    Args:
        event_name: Name of the event.
        properties: Dictionary containing the event's properties.
        context: Dictionary containing some context for this event.
    """

    _track_internal(event_name, properties, context)


def initialize_error_reporting(
    _app: Optional[Sanic] = None, _loop: Optional[asyncio.BaseEventLoop] = None
) -> None:
    """Sets up automated error reporting. Exceptions are reported to Sentry.

    Arguments are injected automatically when registering a Sanic listener.

    Args:
        _app: The Sanic app.
        _loop: The event loop of the Sanic worker.
    """
    if not _context_allows_telemetry():
        return

    import sentry_sdk
    from sentry_sdk.integrations.redis import RedisIntegration
    from sentry_sdk.integrations.sqlalchemy import SqlalchemyIntegration

    # Key for local testing can be found at
    # https://sentry.io/settings/rasahq/projects/rasa-x/install/python/
    # For local testing, set the key using the `SENTRY_WRITE_KEY`
    # environment variable in `docker-compose.dev.yml`.
    key = rasa_x_config.sentry_write_key

    if not get_telemetry_enabled():
        logger.debug(
            "Skipping setup of Sentry error reporting since telemetry is not enabled."
        )
        return

    if not key:
        logger.debug(
            "Skipping setup of Sentry error reporting; write key could not be found."
        )
        return

    sentry_sdk.init(
        f"https://{key}.ingest.sentry.io/5870793",
        integrations=[RedisIntegration(), SqlalchemyIntegration()],
        ignore_errors=[
            RasaException,
            KeyboardInterrupt,  # for local mode only, can probably be removed once dropped
        ],
        server_name=get_telemetry_id() or "UNKNOWN",
        with_locals=False,  # don't submit local variables
        release=f"rasa-x-{__version__}",
        environment=(
            "development" if common_utils.in_continuous_integration() else "production",
        ),
    )
    logger.debug(f"Initialized Sentry error reporting for process id [{os.getpid()}].")


@ensure_telemetry_initialized
def track_project_status(session: Optional[Session] = None) -> None:
    """Tracks an event which describes the current state of the project.

    Args:
        session: Optional database session to use. If not provided, create a
            new one with `session_scope`.
    """
    loop = asyncio.new_event_loop()

    try:
        with db_utils.try_reuse_session_scope(session) as db_session:
            status_event = loop.run_until_complete(
                _get_project_status_event(db_session)
            )

        track(STATUS_EVENT, status_event)
    finally:
        loop.close()


async def _get_project_status_event(
    session: Session, project_id: Text = rasa_x_config.project_name
) -> Dict[Text, Any]:
    """Collect data used in `status` event.

    Args:
        session: Database session.
        project_id: The project ID.

    Returns:
        A dictionary containing statistics describing the current project's status.
    """

    from rasax.community.services.event_service import EventService
    from rasax.community.services.domain_service import DomainService
    from rasax.community.services.model_service import ModelService
    from rasax.community.services.data_service import DataService
    from rasax.community.services.story_service import StoryService
    from rasax.community.services.logs_service import LogsService
    from rasax.community.services.settings_service import SettingsService
    from rasax.community.services.tags_service import TagsService
    from rasax.community.services import stack_service

    event_service = EventService(session)
    domain_service = DomainService(session)
    model_service = ModelService(rasa_x_config.rasa_model_dir, session)
    data_service = DataService(session)
    story_service = StoryService(session)
    logs_service = LogsService(session)
    settings_service = SettingsService(session)
    tags_service = TagsService(session)

    domain = domain_service.get_merged_domain(project_id) or {}
    nlu_data = data_service.get_nlu_training_data_object(project_id=project_id)
    stories = story_service.fetch_stories()
    test_stories = story_service.fetch_stories(fetch_test_stories=True)
    num_conversations = await event_service.get_number_of_conversations()
    num_events = await event_service.get_events_count()
    num_models = model_service.get_model_count()
    lookup_tables = data_service.get_lookup_tables(project_id, include_filenames=True)
    num_lookup_table_files = len({table["filename"] for table in lookup_tables})
    num_lookup_table_entries = sum(
        table.get("number_of_elements", 0) for table in lookup_tables
    )
    synonyms = data_service.get_entity_synonyms(project_id)
    num_synonyms = sum(len(entry["synonyms"]) for entry in synonyms)
    num_regexes = data_service.get_regex_features(project_id).count

    rasa_services = settings_service.stack_services(project_id)
    version_responses = await stack_service.collect_version_calls(
        rasa_services, timeout_in_seconds=ENVIRONMENT_LIVE_TIMEOUT
    )

    environment_names = _environment_names(rasa_services)
    tags = tags_service.get_all_data_tags()
    num_conversations_with_tags = event_service.get_conversations_with_tags_count()
    num_nlu_inbox_messages_with_tags = logs_service.get_message_logs_with_tags_count()

    return {
        # Use the SHA256 of the project ID in case its value contains
        # information about the user's use of Rasa X. On the analytics side,
        # having the original value or the hash makes no difference. This
        # reasoning is also applied on other values sent in this module.
        "project": hashlib.sha256(project_id.encode("utf-8")).hexdigest(),
        "local_mode": rasa_x_config.LOCAL_MODE,
        "rasa_x": __version__,
        "rasa_open_source": _rasa_version(version_responses),
        "num_intent_examples": len(nlu_data.intent_examples),
        "num_entity_examples": len(nlu_data.entity_examples),
        "num_actions": len(domain.get("actions", [])),
        "num_templates": len(
            domain.get("responses", [])
        ),  # Old nomenclature from when 'responses' were still called 'templates' in the domain
        "num_slots": len(domain.get("slots", [])),
        "num_forms": len(domain.get("forms", [])),
        "num_intents": len(domain.get("intents", [])),
        "num_entities": len(domain.get("entities", [])),
        "num_stories": len(stories.result),
        "num_conversations": num_conversations,
        "num_events": num_events,
        "num_models": num_models,
        "num_lookup_table_files": num_lookup_table_files,
        "num_lookup_table_entries": num_lookup_table_entries,
        "num_synonyms": num_synonyms,
        "num_regexes": num_regexes,
        "num_environments": len(environment_names),
        "environment_names": environment_names,
        "num_live_environments": _number_of_live_rasa_environments(version_responses),
        "uptime_seconds": common_utils.get_uptime(),
        "num_tags": len(tags),
        "num_conversations_with_tags": num_conversations_with_tags,
        "num_nlu_inbox_messages_with_tags": num_nlu_inbox_messages_with_tags,
        "num_e2e_tests": len(
            test_stories.result
        ),  # Note: E2E previously meant "test stories"
    }


def _rasa_version(
    version_responses: Dict[Text, Union[Dict[Text, Text], Exception]]
) -> Text:
    """Get the version of the Rasa production environment.

    Args:
        version_responses: `/version` responses of every environment.

    Returns:
        The version of the Rasa production environment or `0.0.0` if there was an error.
    """
    from rasax.community.services.stack_service import RASA_VERSION_KEY

    production_response = version_responses.get(constants.RASA_PRODUCTION_ENVIRONMENT)
    if not isinstance(production_response, dict):
        return constants.INVALID_RASA_VERSION

    return production_response.get(RASA_VERSION_KEY) or constants.INVALID_RASA_VERSION


def _number_of_live_rasa_environments(
    version_responses: Dict[Text, Union[Dict[Text, Text], Exception]]
) -> int:
    """Get the number of Rasa environments which are actually running.

    Args:
        version_responses: `/version` responses of every environment.

    Returns:
        Number of live environments.
    """
    return len([r for r in version_responses.values() if not isinstance(r, Exception)])


def _environment_names(rasa_services: Dict[Text, Any]) -> List[Text]:
    """Names of the configured Rasa Open Source environments.

    Args:
        rasa_services: Mapping of Rasa environment names and their `StackService`
            instances.

    Returns:
        Names of configured Rasa environments.
    """
    return [
        (
            name
            if name
            in [
                constants.RASA_PRODUCTION_ENVIRONMENT,
                constants.RASA_WORKER_ENVIRONMENT,
                constants.RASA_DEVELOPMENT_ENVIRONMENT,
            ]
            else hashlib.sha256(name.encode("utf-8")).hexdigest()
        )
        for name in rasa_services.keys()
    ]


@ensure_telemetry_initialized
def track_story_created(referrer: Optional[Text]) -> None:
    """Tracks an event when a new story is created."""
    if not referrer:
        return

    origin = None
    path = urllib.parse.urlparse(referrer).path

    if path.startswith("/interactive"):
        origin = FROM_INTERACTIVE
    elif path.startswith("/stories"):
        origin = FROM_STORIES

    if origin:
        track(STORY_CREATED_EVENT, {"story_created_from": origin})


@ensure_telemetry_initialized
def track_test_story_created(referrer: Optional[Text]) -> None:
    """Tracks an event when a new test story is created."""
    if not referrer:
        return

    origin = None
    path = urllib.parse.urlparse(referrer).path

    if path.startswith("/interactive"):
        origin = FROM_INTERACTIVE
    elif path.startswith("/stories"):
        origin = FROM_STORIES

    if origin:
        track(E2E_TEST_CREATED_EVENT, {"e2e_test_created_from": origin})


@ensure_telemetry_initialized
def track_message_annotated(origin: Text) -> None:
    """Tracks an event when a message is annotated."""
    track(MESSAGE_ANNOTATED_EVENT, {"message_annotated_from": origin})


@ensure_telemetry_initialized
def track_message_annotated_from_referrer(referrer: Optional[Text] = None) -> None:
    """Tracks an event when a message is annotated.

    This is done using the 'Referer' HTTP header value to determine the origin
    of the event.
    """
    if not referrer:
        return

    path = urllib.parse.urlparse(referrer).path
    origin = MESSAGE_ANNOTATED_NEW_DATA

    if path.startswith("/conversations"):
        origin = MESSAGE_ANNOTATED_CONVERSATIONS
    elif path.startswith("/data") or path.startswith("/training_examples"):
        origin = MESSAGE_ANNOTATED_NEW_DATA

    track_message_annotated(origin)


@ensure_telemetry_initialized
def track_message_received(username: Text, channel: Optional[Text]) -> None:
    """Tracks an event when a message is received."""
    track(
        MESSAGE_RECEIVED_EVENT,
        {
            "username": hashlib.sha256(username.encode("utf-8")).hexdigest(),
            "channel": channel or constants.DEFAULT_CHANNEL_NAME,
        },
    )


async def get_user_groups() -> List[Text]:
    """Return the list of all telemetry user groups the current Rasa X
    telemetry ID belongs to. The list is fetched from an external resource using the
    current telemetry ID.

    Returns:
        List containing strings, each one representing a telemetry group the user
        belongs to (for example, "power users").
    """
    telemetry_id = get_telemetry_id()

    # Check first if we're allowed to make the HTTP request to an external service.
    if not all([_context_allows_telemetry(), get_telemetry_enabled(), telemetry_id]):
        # If not, assume there's no groups.
        return []

    user_groups = []
    params = {"user_id": telemetry_id}

    try:
        async with aiohttp.ClientSession(
            read_timeout=USER_GROUPS_HTTP_TIMEOUT
        ) as session:
            async with session.get(USER_GROUPS_ENDPOINT, params=params) as resp:
                resp.raise_for_status()
                user_groups = await resp.json()

                if not isinstance(user_groups, list):
                    raise ValueError(
                        f"User groups data must be a list, got: {user_groups}"
                    )

                if not all([isinstance(group, str) for group in user_groups]):
                    raise ValueError(
                        f"Each user group must be a string, got: {user_groups}"
                    )
    except Exception as e:
        logger.debug(f"Unable to fetch user groups: {e}")

    return user_groups


def disable_telemetry(session: Optional[Session] = None) -> None:
    """Disable telemetry.

    Note: the server will need to be restarted in order for changes to take effect.

    Args:
        session: SQLAlchemy session, only used in Server mode.
    """
    if rasa_x_config.LOCAL_MODE:
        stored_config = config_utils.read_global_config_value(
            constants.CONFIG_FILE_TELEMETRY_KEY, unavailable_ok=False
        )

        stored_config[constants.CONFIG_TELEMETRY_ENABLED] = False

        config_utils.write_global_config_value(
            constants.CONFIG_FILE_TELEMETRY_KEY, stored_config
        )

        return

    with db_utils.try_reuse_session_scope(session):
        config_service = ConfigService(session)
        config_service.set_value(ConfigKey.TELEMETRY_ENABLED, False)


def get_telemetry_id() -> Optional[Text]:
    """Return the unique telemetry identifier for this Rasa X install.

    The identifier can be any string, but it should be a UUID.

    Returns:
        The identifier, if it is configured correctly.
    """
    telemetry_id = None

    try:
        if rasa_x_config.LOCAL_MODE:
            stored_config = config_utils.read_global_config_value(
                constants.CONFIG_FILE_TELEMETRY_KEY
            )

            if isinstance(stored_config, dict):
                telemetry_id = stored_config.get(constants.CONFIG_TELEMETRY_ID)
        else:
            with db_utils.session_scope() as session:
                config_service = ConfigService(session)
                telemetry_id = config_service.get_value(
                    ConfigKey.TELEMETRY_UUID, expected_type=str
                )
    except Exception as e:
        logger.warning(f"Unable to retrieve telemetry ID: {e}")

    return telemetry_id


def get_telemetry_enabled(session: Optional[Session] = None) -> bool:
    """Returns whether telemetry is enabled in this Rasa X/Enterprise installation.

    Args:
        session: If provided, use this database session in Server mode.

    Returns:
        `True` if telemetry has been enabled, `False` otherwise. The value is retrieved
        from the database in Server mode, and from the global Rasa configuration file in
        the user's home in Local mode.
    """
    if rasa_x_config.LOCAL_MODE:
        try:
            stored_config = config_utils.read_global_config_value(
                constants.CONFIG_FILE_TELEMETRY_KEY, unavailable_ok=False
            )

            return stored_config[constants.CONFIG_TELEMETRY_ENABLED]
        except ValueError:
            return False

    with db_utils.try_reuse_session_scope(session) as db_session:
        config_service = ConfigService(db_session)

        try:
            return config_service.get_value(
                ConfigKey.TELEMETRY_ENABLED, expected_type=bool
            )
        except (InvalidConfigValue, MissingConfigValue):
            return False


def _consume_telemetry_events() -> None:
    """Consume events from the telemetry events queue in a loop.

    When an event is received, send it to Segment.
    """
    common_utils.update_log_level()

    queue = get_events_queue()
    if not queue:
        logger.warning(
            "Can't consume telemetry events as queue has not been initialized."
        )
        return

    telemetry_id = get_telemetry_id()
    telemetry_enabled = get_telemetry_enabled()

    logger.debug("Started consuming telemetry events.")

    while True:
        try:
            event = queue.get()
        except KeyboardInterrupt:
            # Handle Ctrl-C in local mode
            break

        if not telemetry_id:
            logger.warning("Skip sending telemetry event as no ID was found.")
            continue

        if not telemetry_enabled:
            logger.debug("Skip sending telemetry event as telemetry is disabled.")
            continue

        try:
            properties = event["properties"]
            if properties:
                properties[TELEMETRY_ID] = telemetry_id

            _send_event(telemetry_id, event["name"], properties, event["context"])
        except Exception as e:
            logger.warning(
                f"An error occured when trying to send the telemetry event: {e}"
            )


def _initialize_telemetry_process() -> "Process":
    """Create the process that consumes events from the telemetry queue.

    Returns:
        Created process (already running).
    """
    return common_utils.run_in_process(_consume_telemetry_events)


def _read_telemetry_consent(no_prompt: bool) -> bool:
    """Check if the user wants to enable telemetry or not.

    Args:
        no_prompt: If `True`, do not prompt the user for input (but inform
            about any decision taken).

    Returns:
        Boolean indicating if the user wants to enable telemetry.
    """
    import questionary

    allow_telemetry = (
        questionary.confirm(
            "Rasa will track a minimal amount of anonymized usage information "
            "(like how often the 'train' button is used) to help us improve Rasa X. "
            "None of your training data or conversations will ever be sent to Rasa. "
            "Are you OK with Rasa collecting anonymized usage data?"
        )
        .skip_if(no_prompt, default=True)
        .ask()
    )

    if not no_prompt:
        cli_utils.print_success(
            f"Your decision has been stored into '{constants.GLOBAL_USER_RASA_CONFIG_PATH}'."
        )
    else:
        cli_utils.print_info(
            "By adding the '--no_prompt' parameter you agreed to allow Rasa to track "
            "and send anonymized usage information."
        )

    return allow_telemetry


def initialize_from_file(no_prompt: bool) -> Optional["Process"]:
    """Reads telemetry configuration from the user's Rasa config file.

    After that is done, start consuming the telemetry events queue
    from a different process.

    Args:
        no_prompt: If `True`, do not prompt the user for input.

    Returns:
        Process running the telemetry events consumer loop.
    """
    if not rasa_x_config.LOCAL_MODE:
        logger.error(
            "Attempted to read telemetry configuration file in $HOME while in server "
            "mode. Telemetry will not be enabled."
        )
        return None

    telemetry_enabled = None

    try:
        stored_config = config_utils.read_global_config_value(
            constants.CONFIG_FILE_TELEMETRY_KEY, unavailable_ok=False
        )

        telemetry_enabled = stored_config[constants.CONFIG_TELEMETRY_ENABLED]
    except ValueError as e:
        logger.debug(f"Could not read telemetry settings from configuration file: {e}")

    if telemetry_enabled is None:
        telemetry_enabled = _read_telemetry_consent(no_prompt)

        new_config = {
            constants.CONFIG_TELEMETRY_ENABLED: telemetry_enabled,
            constants.CONFIG_TELEMETRY_ID: uuid.uuid4().hex,
            constants.CONFIG_TELEMETRY_DATE: datetime.datetime.now(),
            constants.CONFIG_TELEMETRY_WELCOME_SHOWN: False,
        }

        config_utils.write_global_config_value(
            constants.CONFIG_FILE_TELEMETRY_KEY, new_config
        )

    return _initialize_telemetry_process()


def initialize_from_db(
    session: Session, overwrite_configuration: bool = True
) -> Optional["Process"]:
    """Reads telemetry configuration from the database.

    After that is done, start consuming the telemetry events queue from a different
    process.

    Args:
        session: Database session to use.
        overwrite_configuration: `True` if any modified telemetry config should
            be persisted in the database. E.g. the `EventService` should not override
            configuration made by Rasa X.

    Returns:
        Process running the telemetry events consumer loop.
    """
    if rasa_x_config.LOCAL_MODE:
        logger.error(
            "Attempted to read telemetry configuration from the database while in "
            "local mode. Telemetry will not be enabled."
        )
        return None

    config_service = ConfigService(session)

    telemetry_enabled = _default_enabled_value(session)

    try:
        telemetry_enabled = config_service.get_value(
            ConfigKey.TELEMETRY_ENABLED, expected_type=bool
        )
    except (MissingConfigValue, InvalidConfigValue):
        logger.debug(
            "Telemetry was not configured yet. It is now configured with "
            "the defaults."
        )

    if overwrite_configuration:
        # Always save the value back to the database to make sure we remember
        # potentially set environment variables
        config_service.set_value(ConfigKey.TELEMETRY_ENABLED, telemetry_enabled)

    return _initialize_telemetry_process()


def _default_enabled_value(session: Session) -> bool:
    from rasax.community.services.license_service import LicenseService

    return not LicenseService.is_enterprise_activated(session)


@ensure_telemetry_initialized
def track_repository_creation(target_branch: Text, created_via_ui: bool) -> None:
    """Tracks when a new Git repository was connected to Rasa X server.

    Args:
        target_branch: The target branch of this repository.
        created_via_ui: `True` if the repository was created using the Rasa X UI.
    """
    track(
        REPOSITORY_CREATED_EVENT,
        {"branch": target_branch, "created_with_ui": created_via_ui},
    )


@ensure_telemetry_initialized
def track_git_changes_pushed(branch: Text) -> None:
    """Track when changes were pushed to the remote Git repository.

    Args:
        branch: Name of the branch the changes were pushed to.
    """
    track(GIT_CHANGES_PUSHED_EVENT, {"branch": branch})


@ensure_telemetry_initialized
def track_feature_flag(feature_name: Text, enabled: bool) -> None:
    """Track when a feature flag was enabled / disabled.

    Args:
        feature_name: Name of the feature.
        enabled: `True` if the feature was enabled, otherwise `False`.
    """
    track(FEATURE_FLAG_UPDATED_EVENT, {"name": feature_name, "enabled": enabled})


def track_conversation_review_status_update(
    review_status: Text, previous_review_status: Text
) -> None:
    """
    Track when the review status of a conversation is updated. It uses
    the new and previous review status of a conversation.

    Args:
        review_status: the new review status of the conversation
        previous_review_status: the previous review status of the conversation
    """
    event_name = None
    if (
        review_status == constants.CONVERSATION_STATUS_REVIEWED
        and previous_review_status != constants.CONVERSATION_STATUS_REVIEWED
    ):
        event_name = CONVERSATION_REVIEWED
    elif (
        review_status == constants.CONVERSATION_STATUS_SAVED_FOR_LATER
        and previous_review_status != constants.CONVERSATION_STATUS_SAVED_FOR_LATER
    ):
        event_name = CONVERSATION_SAVED_FOR_LATER
    elif (
        review_status == constants.CONVERSATION_STATUS_UNREAD
        and previous_review_status == constants.CONVERSATION_STATUS_REVIEWED
    ):
        event_name = CONVERSATION_UNDO_REVIEWED
    elif (
        review_status == constants.CONVERSATION_STATUS_UNREAD
        and previous_review_status == constants.CONVERSATION_STATUS_SAVED_FOR_LATER
    ):
        event_name = CONVERSATION_UNDO_SAVED_FOR_LATER
    else:
        # nothing to track
        return

    track(event_name)


@ensure_telemetry_initialized
def track_conversation_tagged(count: int) -> None:
    """Track an event when a conversation is tagged with one or more tags.

    Args:
        count: Number of tags assigned to the conversation.
    """
    track(CONVERSATION_TAGGED, {"count": count})


@ensure_telemetry_initialized
def track_message_tagged(count: int) -> None:
    """Track an event when a message is tagged with one or more tags.

    Args:
        count: Number of tags assigned to the message.
    """
    track(MESSAGE_TAGGED, {"count": count})


@ensure_telemetry_initialized
def track_conversations_imported(process_id: Text) -> None:
    """Track when conversations were imported through a `rasa export` call.

    Args:
        process_id: Import process ID.
    """
    track(CONVERSATIONS_IMPORTED_EVENT, {"process_id": process_id})


@ensure_telemetry_initialized
def track_server_start() -> None:
    """Send the initial telemetry events when the server starts."""
    track(
        SERVER_START_EVENT,
        {"quick_install": _was_deployed_using_quick_install_script()},
    )

    track_project_status()


def _was_deployed_using_quick_install_script() -> bool:
    return os.environ.get("QUICK_INSTALL", "true").lower() == "true"


@ensure_telemetry_initialized
def track_training_failed(rasa_open_source: str, total_training_time: float) -> None:
    """Tracks an event when a model training fails.

    Args:
        rasa_open_source: Rasa Open Source version.
        total_training_time: The total time it took to complete training.
    """
    track(
        MODEL_TRAINING_FAILED_EVENT,
        {
            "rasa_open_source": rasa_open_source,
            "total_training_time": total_training_time,
        },
    )
