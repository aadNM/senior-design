import json
from datetime import datetime
from typing import Text, List, Dict, Any, Optional, Union, Tuple

from sanic.request import Request
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import selectinload

import rasax.community.utils.common as common_utils
from rasax.community.database.assistant import (
    BusinessLogicFlow,
    BusinessLogicFlowElement,
    SampleConversation,
    SampleConversationItem,
    AssistantLink,
)
from rasax.community.database.service import DbService


class AssistantService(DbService):
    """A service used to work with assistant-related models."""

    @staticmethod
    def from_request(request: Request, **kwargs) -> "AssistantService":
        """Construct `InsightService` from an incoming HTTP request.

        Args:
            request: Incoming HTTP request.
            **kwargs: Other key-value args, not used.

        Returns:
            Constructed `InsightService` object.
        """
        return AssistantService(request.ctx.db_session)

    def fetch_flows(
        self, limit: int = 30, offset: int = 0, search: Optional[Text] = None
    ) -> common_utils.QueryResult:
        """Fetches Business Logic Flows.

        Args:
            limit:  limit to use for the query, defaults to 30
            offset: offset to use for the query, defaults to 0
            search: only return `BusinessLogicFlow`s that contain this text, defaults to None

        Returns:
            QueryResult with `BusinessLogicFlow`s matching the query.
        """
        query = self.query(BusinessLogicFlow).order_by(
            BusinessLogicFlow.updated_at.desc()
        )

        if search:
            query = query.filter(BusinessLogicFlow.name.ilike(f"%{search}%"))

        count = query.count()
        query = query.limit(limit).offset(offset)

        result = [flow.as_dict() for flow in query.all()]
        return common_utils.QueryResult(result, count)

    def get_flow(self, flow_id: Any) -> Optional[BusinessLogicFlow]:
        """Gets Business Logic Flow by id.

        Args:
            flow_id: ID of the Business Logic Flow.

        Return:
            BusinessLogicFlow or `None` if none could be found with the given ID.
        """
        try:
            lookup_id = int(flow_id)
            return self.query(BusinessLogicFlow).get(lookup_id)
        except (ValueError, TypeError):
            return None

    def create_flow(
        self,
        name: Text,
        elements: List[Dict[Text, Any]],
        description: Text = None,
        created_at: datetime = None,
        updated_at: datetime = None,
    ) -> BusinessLogicFlow:
        """Creates a new Business Logic Flow.

        Args:
            name:        a unique name.
            elements:    a list of flowchart steps and arrows as dicts.
            description: optional value for further describing the business logic flow.
            created_at:  optional value when it was created, if missing uses `datetime.utcnow()`
            updated_at:  optional value when it was updated, if missing uses `datetime.utcnow()`

        Raises:
            DuplicateBusinessLogicFlowException: When a business logic flow with the same name already exists.

        Returns:
            Created `BusinessLogicFlow`.
        """
        try:
            flow = BusinessLogicFlow(
                name=name,
                description=description,
                created_at=created_at,
                updated_at=updated_at,
            )
            flow.elements = self._parse_flow_elements(elements)
            self.add(flow)

            self.flush()
            return flow
        except IntegrityError:
            self.rollback()
            raise DuplicateBusinessLogicFlowException()

    def update_flow(self, flow_id: Any, data: Dict[Text, Any],) -> BusinessLogicFlow:
        """Patch updates a Business Logic Flow.

        This method only updates the flow values when they're present in the data dictionary.
        When a key is present with a `None` value then this field will be set to `None`.

        Args:
            flow_id:     ID of the Business Logic Flow.
            data:    the data to update to potentially containing a name, description, and elements

        Raises:
            ValueError: when a flow with the given ID cannot be found.
            BusinessLogicFlowParseException: when the given elements cannot be parsed.

        Returns:
            Updated `BusinessLogicFlow`.
        """
        flow = self.get_flow(flow_id)

        if flow is None:
            raise ValueError()

        try:
            if "name" in data:
                flow.name = data["name"]
            if "description" in data:
                flow.description = data["description"]
            if "elements" in data:
                self._merge_elements(flow, data["elements"])

            self.flush()
            self.session.refresh(flow)
            return flow
        except IntegrityError:
            self.session.rollback()
            raise DuplicateBusinessLogicFlowException()

    def delete_flow(self, flow_id: Any) -> None:
        """Deletes a Business Logic Flow if it exists.

        Args:
            flow_id: ID of the Business Logic Flow.

        Raises:
            ValueError: when a flow with the given ID cannot be found.
        """
        flow = self.get_flow(flow_id)

        if flow is None:
            raise ValueError()

        self.delete(flow)
        self.flush()

    def fetch_sample_conversations(
        self, limit: int = 30, offset: int = 0, search: Optional[Text] = None,
    ) -> common_utils.QueryResult:
        """Fetches Sample Conversations.

        Args:
            limit:  limit to use for the query, defaults to 30
            offset: offset to use for the query, defaults to 0
            search: only return SampleConversations that contain this text

        Returns:
            QueryResult with `SampleConversation`s matching the query.
        """
        query = self.query(SampleConversation).order_by(
            SampleConversation.updated_at.desc()
        )

        if search:
            query = query.filter(SampleConversation.name.ilike(f"%{search}%"))

        count = query.count()
        query = query.limit(limit).offset(offset)

        result = [conv.as_dict() for conv in query.all()]
        return common_utils.QueryResult(result, count)

    def get_sample_conversation(
        self, sample_conversation_id: Any
    ) -> Optional[SampleConversation]:
        """Gets Sample Conversation by id.

        Args:
            sample_conversation_id: ID of the Sample Conversation.

        Return:
            SampleConversation or `None` if none could be found with the given ID.
        """
        try:
            lookup_id = int(sample_conversation_id)
            return self.query(SampleConversation).get(lookup_id)
        except (ValueError, TypeError):
            return None

    def create_sample_conversation(
        self,
        name: Text,
        description: Text = None,
        created_at: Optional[datetime] = None,
        updated_at: Optional[datetime] = None,
    ) -> SampleConversation:
        """Creates a sample conversation.

        Args:
            name:        The name of the conversation.
            description: optional value for further describing the sample conversation.
            created_at:  optional value when it was created, if missing uses `datetime.utcnow()`
            updated_at:  optional value when it was updated, if missing uses `datetime.utcnow()`

        Returns:
            Created `SampleConversation`
        """
        try:
            sample_conversation = SampleConversation(
                name=name,
                description=description,
                created_at=created_at,
                updated_at=updated_at,
            )
            self.session.add(sample_conversation)
            self.session.flush()
            return sample_conversation
        except IntegrityError:
            self.session.rollback()
            raise DuplicateSampleConversationException()

    def update_sample_conversation(
        self, sample_conversation_id: Any, name: Text, description: Text,
    ) -> SampleConversation:
        """Updates a Sample Conversation.

        Args:
            sample_conversation_id: ID of the Business Logic Flow.
            name:                   a unique name.
            description:            a string for further describing the business logic flow.

        Raises:
            ValueError: when a sample conversation with the given ID cannot be found.

        Returns:
            Updated `SampleConversation`.
        """
        conversation = self.get_sample_conversation(sample_conversation_id)

        if conversation is None:
            raise ValueError()

        try:
            conversation.name = name
            conversation.description = description

            self.flush()
            return conversation
        except IntegrityError:
            self.session.rollback()
            raise DuplicateSampleConversationException()

    def create_sample_conversation_message(
        self, type_: Text, text: Text, sample_conversation_id: Any
    ) -> SampleConversationItem:
        """Creates message to an existing sample conversation.

        Args:
            type_: The type of the message (`user_message` or `bot_message`).
            text: The text of the message.
            sample_conversation_id: The ID of the sample conversation this message is part of.

        Returns:
            The created `SampleConversationItem`.

        Raises:
            `ValueError` when one or more given values are invalid or missing.
        """
        conversation = self.get_sample_conversation(sample_conversation_id)
        if conversation is None:
            raise ValueError("sample conversation does not exist")

        message = SampleConversationItem(
            type=type_, text=text, conversation=conversation
        )
        self.session.add(message)
        self.session.flush()
        conversation.updated_at = message.updated_at

        return message

    def delete_sample_conversation(self, sample_conversation_id: Any) -> None:
        """Deletes a Sample Conversation if it exists.

        Args:
            sample_conversation_id: ID of the Sample Conversation.

        Raises:
            ValueError: when a sample conversation with the given ID cannot be found.
        """
        conversation = self.get_sample_conversation(sample_conversation_id)

        if conversation is None:
            raise ValueError()

        self.delete(conversation)
        self.flush()

    def delete_sample_conversation_message(
        self, sample_conversation_item_id: Any
    ) -> None:
        """Deletes a Sample Conversation Message if it exists.

        Args:
            sample_conversation_item_id: ID of the Sample Conversation Item.

        Raises:
            ValueError: when a sample conversation item with the given ID cannot be found.
        """
        try:
            lookup_id = int(sample_conversation_item_id)
            item = self.query(SampleConversationItem).get(lookup_id)

            if item is None:
                raise ValueError()

            self.delete(item)
            self.flush()
        except TypeError:
            raise ValueError()

    def update_sample_conversation_message(
        self,
        type_: Text,
        text: Text,
        sample_conversation_id: Any,
        sample_conversation_item_id: Any,
    ) -> SampleConversationItem:
        """Updates a Sample Conversation Message if it exists.

        type_: The type of the message (`user_message` or `bot_message`).
        text: The text of the message.
        sample_conversation_id: The ID of the sample conversation this message is part of.
        sample_conversation_item_id: ID of the Sample Conversation Item.

        Raises:
            ValueError: when a sample conversation item with the given ID cannot be found.

        Returns:
            Updated `SampleConversationItem`.
        """
        try:
            lookup_id = int(sample_conversation_item_id)
            item = self.query(SampleConversationItem).get(lookup_id)

            if item is None:
                raise ValueError(
                    "Could not find a sample conversation item with the given ID."
                )

            conversation = self.get_sample_conversation(sample_conversation_id)

            if conversation is None:
                raise ValueError("sample conversation does not exist")

            item.type = type_
            item.text = text

            self.flush()
            conversation.updated_at = item.updated_at
            return item
        except TypeError:
            raise ValueError()

    def fetch_links(
        self,
        business_logic_flow_id: Optional[int] = None,
        sample_conversation_id: Optional[int] = None,
        limit: int = 30,
        offset: int = 0,
    ) -> common_utils.QueryResult:
        """Fetches Assistant Links.

        Args:
            business_logic_flow_id: the business logic flow id to filter links for.
            sample_conversation_id: the sample conversation id to filter links for.
            limit:                  limit to use for the query, defaults to 30
            offset:                 offset to use for the query, defaults to 0

        Raises:
            ValueError: when trying to filter for both `business_logic_flow_id` and `sample_conversation_id`.

        Returns:
            QueryResult with `AssistantLink`s matching the query.
        """
        if business_logic_flow_id and sample_conversation_id:
            raise ValueError(
                "Can only filter for `business_logic_flow_id` or `sample_conversation_id`, not both."
            )

        query = self.query(AssistantLink).order_by(AssistantLink.updated_at.desc())

        if business_logic_flow_id:
            query = query.filter_by(business_logic_flow_id=business_logic_flow_id)

        if sample_conversation_id:
            query = query.filter_by(example_conversation_id=sample_conversation_id)

        count = query.count()
        query = query.options(
            selectinload(AssistantLink.flow), selectinload(AssistantLink.conversation)
        )
        query = query.limit(limit).offset(offset)
        result = [link.as_dict(embed_linked_objects=True) for link in query.all()]

        return common_utils.QueryResult(result, count)

    def bulk_create_links(
        self, data: List[Dict[Text, int]], handle_transaction: bool = True
    ) -> List[Dict[Text, Any]]:
        """Bulk create assistant links.

        Args:
            data:               A list of dictionaries containing business logic flow and sample conversation ids.
            handle_transaction: Should database transactions be handled automatically? Defaults to `True`.

        Raises:
            BulkCreateException: when assistant link is duplicate or linked objects don't exist.

        Returns:
            List of created assistant links as a dictionary.
        """
        created_links = []
        create_errors = []

        for link_data in data:
            flow_id = link_data["business_logic_flow_id"]
            conversation_id = link_data["sample_conversation_id"]

            link, errors = self._bulk_create_single_link(flow_id, conversation_id)
            if link:
                created_links.append(link)
            else:
                create_errors.extend(errors)

        if create_errors:
            if handle_transaction:
                self.session.rollback()
            raise BulkCreateException(create_errors)

        if handle_transaction:
            self.session.commit()
        else:
            self.session.flush()

        ids = [link.id for link in created_links]
        links = (
            self.session.query(AssistantLink)
            .options(
                selectinload(AssistantLink.flow),
                selectinload(AssistantLink.conversation),
            )
            .filter(AssistantLink.id.in_(ids))
        )
        return [link.as_dict(embed_linked_objects=True) for link in links]

    def delete_link(self, link_id: Any) -> None:
        """Delete an assistant link.

        Args:
            link_id: The ID of the link to be deleted.

        Raises:
            ValueError: when no link can be found with the given ID.
        """
        try:
            lookup_id = int(link_id)
            link = self.query(AssistantLink).get(lookup_id)

            if link is None:
                raise ValueError

            self.delete(link)
            self.flush()
        except (ValueError, TypeError):
            raise ValueError("Assistant Link with given ID does not exist")

    @staticmethod
    def _parse_flow_elements(
        elements: List[Dict[Text, Any]]
    ) -> List[BusinessLogicFlowElement]:
        """Parses flow elements and returns initialized `BusinessLogicFlowElement` objects."""
        flow_elements = []

        for element in elements:
            flow_element = BusinessLogicFlowElement()
            try:
                flow_element.update_with_data(element)
            except ValueError as e:
                raise BusinessLogicFlowParseException(str(e))
            flow_elements.append(flow_element)

        return flow_elements

    def _merge_elements(
        self, flow: BusinessLogicFlow, elements: List[Dict[Text, Any]]
    ) -> None:
        """Parses flow elements and merges them with elements of an existing business logic flow."""
        parsed_elements = self._parse_flow_elements(elements)

        def _find_by_element_id(
            flow_elements: List[BusinessLogicFlowElement], element_id: Text
        ) -> Union[None, BusinessLogicFlowElement]:
            for element in flow_elements:
                if element.element_id == element_id:
                    return element
            return None

        existing_element_ids = {e.element_id for e in flow.elements}
        input_element_ids = {e.element_id for e in parsed_elements}
        element_ids_to_delete = existing_element_ids - input_element_ids
        for delete_id in element_ids_to_delete:
            existing_element = _find_by_element_id(flow.elements, delete_id)
            self.delete(existing_element)

        for input_element in parsed_elements:
            existing_element = _find_by_element_id(
                flow.elements, input_element.element_id
            )
            if existing_element is None:
                flow.elements.append(input_element)
            else:
                existing_element.update_with_data(json.loads(input_element.data))

    def _bulk_create_single_link(
        self, flow_id: int, conversation_id: int
    ) -> Tuple[Optional[AssistantLink], List[Text]]:
        errors = []

        flow = self.get_flow(flow_id)
        conversation = self.get_sample_conversation(conversation_id)

        error_prefix = f"Cannot create link with Business Logic Flow id {flow_id} and Sample Conversation id {conversation_id}"
        if flow is None:
            errors.append(f"{error_prefix} - Business Logic Flow does not exist.")
        if conversation is None:
            errors.append(f"{error_prefix} - Sample Conversation does not exist.")

        existing_count = (
            self.session.query(AssistantLink)
            .filter_by(
                business_logic_flow_id=flow_id, example_conversation_id=conversation_id,
            )
            .count()
        )
        if existing_count > 0:
            errors.append(f"{error_prefix} - Assistant Link already exists.")

        if errors:
            return None, errors

        link = AssistantLink(
            business_logic_flow_id=flow.id, example_conversation_id=conversation.id,
        )
        self.session.add(link)

        return link, errors


class DuplicateBusinessLogicFlowException(Exception):
    """Exception for a business logic flow with a duplicate name."""

    pass


class BusinessLogicFlowParseException(Exception):
    """Exception when parsing invalid business logic flow elements."""

    pass


class DuplicateSampleConversationException(Exception):
    """Exception for a sample conversation with a duplicate name."""

    pass


class BulkCreateException(Exception):
    """Exception for when a bulk create operation failed with potentially multiple error messages."""

    def __init__(self, errors: List[Text]) -> None:
        """Initialize bulk create exception.

        Args:
            errors: List of error messages.
        """
        super().__init__("Bulk create operation failed.")
        self.errors = errors
