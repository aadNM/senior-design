import asyncio
import json

import logging
import typing
from http import HTTPStatus
from typing import Any, Dict, List, Optional, Text, Union, Tuple

import aiohttp
from aiohttp import ClientError, ClientSession
from concurrent.futures import TimeoutError

from sanic.request import Request

from rasa.shared.core.events import Restarted
from rasa.shared.core.trackers import EventVerbosity
import rasa.shared.utils.io

import rasax.community.jwt
import rasax.community.utils.io as io_utils
import rasax.community.utils.yaml as yaml_utils
import rasax.community.config as rasa_x_config
import rasax.community.constants as constants
import rasax.community.utils.common as common_utils
import rasax.community.telemetry as telemetry
from rasax.community.services.user_service import GUEST
from rasax.community.database.model import TrainingStatus, ModelTrainingJob
from rasax.community.services.model_service import ModelService
from rasax.community.services.nlg_service import NlgService


if typing.TYPE_CHECKING:
    from rasax.community.services.data_service import DataService
    from rasax.community.services.story_service import StoryService
    from rasax.community.services.domain_service import DomainService
    from rasax.community.services.settings_service import SettingsService


logger = logging.getLogger(__name__)

RASA_VERSION_KEY = "version"
INCLUDE_EVENTS_QUERY_PARAM = "include_events"
TOKEN_QUERY_PARAM = "token"


def _model_service(request: Request) -> ModelService:
    return ModelService.from_request(
        rasa_x_config.rasa_model_dir, request, constants.DEFAULT_RASA_ENVIRONMENT
    )


class RasaCredentials(typing.NamedTuple):
    """Credentials to connect and authenticate to a Rasa Open Source environment."""

    url: Text
    token: Text


class TrainingError(Exception):
    """Errors when training fails from Rasa Open Source."""

    def __init__(self, rasa_version: Text, message: Text):
        """Creates a `TrainingError` instance.

        Args:
            message: Training error message.
            rasa_version: Rasa Open Source version.
        """
        super().__init__(message)
        self.rasa_version = rasa_version


class StackService:
    """Connects to a running Rasa server.

    Used to retrieve information about models and conversations.
    """

    def __init__(
        self,
        credentials: RasaCredentials,
        data_service: "DataService",
        story_service: "StoryService",
        domain_service: "DomainService",
        settings_service: "SettingsService",
    ) -> None:
        """Create a `StackService` instance.

        Args:
            credentials: Credentials for connecting to the Rasa instance.
            data_service: Service to obtain the current NLU training data.
            story_service: Service to obtain the Rasa Core stories training data.
            domain_service: Service to obtain the Rasa Core domain for the training.
            settings_service: Service to obtain the current model config.
        """

        self.rasa_credentials = credentials
        self.data_service = data_service
        self.story_services = story_service
        self.domain_service = domain_service
        self.settings_service = settings_service

    async def version(
        self,
        timeout_in_seconds: Optional[
            float
        ] = rasa_x_config.RASA_VERSION_TIMEOUT_IN_SECONDS,
    ) -> Any:
        """Call the `/version` endpoint of the Rasa Open Source API.

        Response Example:
        {
            "version": "1.9.5",
            "minimum_compatible_version": "1.9.0"
        }

        Args:
            timeout_in_seconds: Request timeout in seconds which is used for the call.

        Returns:
            Request response.
        """
        async with self._session() as session:
            response = await session.get(
                self._request_url("/version"),
                params=self._query_parameters(),
                timeout=timeout_in_seconds,
            )
            return await response.json()

    @staticmethod
    def _session(raise_for_status: bool = True) -> ClientSession:
        """Create session for requests to a Rasa Open Source instance.

        Args:
            raise_for_status: If `True` automatically call raise_for_status() for response.
                If `False` handle response explictly.

        Returns:
            Session with default configuration.
        """
        return aiohttp.ClientSession(
            timeout=aiohttp.ClientTimeout(total=constants.DEFAULT_REQUEST_TIMEOUT),
            raise_for_status=raise_for_status,
        )

    def _request_url(self, sub_path: Text) -> Text:
        """Create the full URL for requests to the Rasa Open Source instance.

        Args:
            sub_path: Path of the resource which should be requested. This is the part
                after the host or port in the URL.

        Returns:
            Full URL.
        """
        import urllib.parse as urllib

        return urllib.urljoin(self.rasa_credentials.url, sub_path)

    def _query_parameters(
        self, params: Optional[Dict[Text, Any]] = None
    ) -> Dict[Text, Any]:
        """Create the query parameters for a request to the Rasa Open Source instance.

        Args:
            params: Optional query parameters for the requests.

        Returns:
            Passed query parameters including the default query parameters.
        """
        params = params or {}
        if self.rasa_credentials.token:
            params[TOKEN_QUERY_PARAM] = self.rasa_credentials.token

        return params

    async def rasa_version(self, timeout_in_seconds: Optional[float] = None) -> Text:
        """Retrieve the Rasa Open Source version.

        Calls the `/version` endpoint of the Rasa Open Source API and extracts
        the Rasa Open Source version from the response.

        Args:
            timeout_in_seconds: Request timeout in seconds for getting the version.

        Returns:
            The version or `0.0.0` in case there was an error.
        """
        try:
            status_response = await self.version(timeout_in_seconds)
            return status_response.get(RASA_VERSION_KEY, constants.INVALID_RASA_VERSION)
        except (ClientError, TimeoutError, asyncio.TimeoutError) as e:
            # Use `debug` logging level to avoid printing logs when Rasa Open Source
            # is not yet up
            logger.debug(f"Error when retrieving version from Rasa Open Source. {e}")
            return constants.INVALID_RASA_VERSION

    async def has_active_model(self) -> bool:
        """Returns whether service has an active model."""

        try:
            async with self._session() as session:
                response = await session.get(
                    self._request_url("/status"), params=self._query_parameters()
                )
                response_body = await response.json()

                return response_body.get("fingerprint") != {}
        except ClientError:
            return False

    async def server_status(
        self, timeout_in_seconds: Optional[float] = None
    ) -> Optional[Dict[Text, Any]]:
        """Queries the service's `/status` endpoint.

        Args:
            timeout_in_seconds: Request timeout in seconds which is used for the call.

        Returns:
            The JSON response of the service's `/status` endpoint.
        """
        try:
            async with self._session() as session:
                response = await session.get(
                    self._request_url("/status"),
                    params=self._query_parameters(),
                    timeout=timeout_in_seconds,
                )
                return await response.json()
        except ClientError:
            return None

    async def tracker_json(
        self,
        conversation_id: Text,
        event_verbosity: EventVerbosity = EventVerbosity.ALL,
        until: Optional[int] = None,
    ) -> Any:
        """Retrieve a tracker's json representation from remote instance."""
        url = f"/conversations/{conversation_id}/tracker"

        params = {
            INCLUDE_EVENTS_QUERY_PARAM: event_verbosity.name,
        }
        if until:
            params["until"] = until

        async with self._session() as session:
            response = await session.get(
                self._request_url(url), params=self._query_parameters(params)
            )
            return await response.json()

    async def update_events(
        self, conversation_id: Text, events: List[Dict[Text, Any]]
    ) -> Any:
        """Update events in the tracker of a conversation."""

        # don't overwrite existing events but rather restart the conversation
        # and append the updated events.
        events = [Restarted().as_dict()] + events

        return await self.append_events_to_tracker(conversation_id, events)

    async def append_events_to_tracker(
        self,
        conversation_id: Text,
        events: Union[Dict[Text, Any], List[Dict[Text, Any]]],
    ) -> Any:
        """Add some more events to the tracker of a conversation."""

        url = f"/conversations/{conversation_id}/tracker/events"

        async with self._session() as session:
            response = await session.post(
                self._request_url(url), params=self._query_parameters(), json=events
            )
            return await response.json()

    async def execute_action(
        self, conversation_id: Text, action: Dict, event_verbosity: EventVerbosity
    ) -> Any:
        """Run an action in a conversation."""

        url = f"/conversations/{conversation_id}/execute"
        params = {INCLUDE_EVENTS_QUERY_PARAM: event_verbosity.name}

        async with self._session() as session:
            response = await session.post(
                self._request_url(url),
                params=self._query_parameters(params),
                json=action,
            )
            return await response.json()

    async def evaluate_story(self, story: Text) -> Any:
        """Evaluate a story at Core's /evaluate endpoint."""
        url = "/model/test/stories"

        async with self._session() as session:
            response = await session.post(
                self._request_url(url),
                params=self._query_parameters(),
                data=story,
                timeout=300,
            )
            return await response.json()

    async def send_message(self, message: Dict[Text, Text], token: Text) -> Any:
        """Sends user messages to the stack Rasa webhook.

        Returns:
            If the request was successful the result as a list, otherwise
            `None`.
        """

        url = "/webhooks/rasa/webhook"

        async with self._session() as session:
            response = await session.post(
                self._request_url(url), headers={"Authorization": token}, json=message
            )
            return await response.json()

    @staticmethod
    def get_user_properties_from_bearer(
        token: Text, public_key: Union[Text, bytes, None] = None
    ) -> Tuple[Text, Optional[Text]]:
        """Given a value of a HTTP Authorization header, verifies its validity
        as a JWT token and returns two values inside its payload: the user's
        name and their role.

        Returns:
            A tuple containing the input channel and the username.
        """

        if not public_key:
            public_key = rasa_x_config.jwt_public_key

        jwt_payload = rasax.community.jwt.verify_bearer_token(
            token, public_key=public_key
        )
        user = jwt_payload.get("user", {})
        username = user.get(constants.USERNAME_KEY)
        user_roles = user.get("roles", [])

        if GUEST in user_roles:
            input_channel = constants.SHARE_YOUR_BOT_CHANNEL_NAME
        else:
            input_channel = constants.DEFAULT_CHANNEL_NAME

        return input_channel, username

    @staticmethod
    def _get_responses_file_name() -> Text:
        """Load the name of the file with responses."""

        return str(
            io_utils.get_project_directory()
            / rasa_x_config.data_dir
            / rasa_x_config.default_responses_filename
        )

    async def parse(self, text: Text) -> Optional[Dict]:
        url = "/model/parse"
        async with self._session() as session:
            response = await session.post(
                self._request_url(url),
                params=self._query_parameters(),
                headers={"Accept": "application/json"},
                json={"text": text},
            )
            return await response.json()

    async def start_training_process(
        self,
        callback_url: Text,
        team: Text = rasa_x_config.team_name,
        project_id: Text = rasa_x_config.project_name,
    ) -> None:
        """Request training from Rasa OSS.

        Args:
            callback_url: The URL for the callback endpoint that the results will be
                posted to.
            team: User's team.
            project_id: The current project's ID.
        """
        from rasax.community.services.data_service import DataService

        url = "/model/train"

        nlu_training_data = self.data_service.get_nlu_training_data_object(
            project_id=project_id, should_include_lookup_table_entries=True
        )
        nlu = DataService.training_data_to_dict(nlu_training_data)
        stories = self.story_services.get_all_stories_dict(project_id)
        domain = self.domain_service.get_merged_domain(project_id)
        config = self.settings_service.get_config(team, project_id)

        # Combine everything into a single dict that will be converted to YAML
        # Since the "responses" key can appear in both NLU data and in the domain,
        # merge those separately before.
        responses = {
            "responses": {**nlu.pop("responses", {}), **domain.pop("responses", {})}
        }
        contents = {**nlu, **stories, **domain, **config, **responses}

        async with self._session(raise_for_status=False) as session:
            params = self._query_parameters(
                {
                    "force": "true",
                    "save_to_default_model_directory": "true",
                    "callback_url": callback_url,
                }
            )

            response = await session.post(
                self._request_url(url),
                headers={"Content-Type": "application/x-yaml"},
                params=params,
                data=yaml_utils.dump_yaml(contents),
                timeout=60 * 60,  # 1 minute
            )

            response.raise_for_status()

    async def complete_training_process(
        self,
        request: Request,
        job: ModelTrainingJob,
        project_id: Text = rasa_x_config.project_name,
    ) -> Tuple[Optional[Text], Dict[Text, Any]]:
        """Completes training process.

        Perform all necessary operations needed after receiving model training result
        from Rasa OSS, and update model training job.

        Args:
            request: The incoming request.
            job: A model training job.
            project_id: ID of the project.

        Returns:
            A tuple containing the model name if available and the updated model training job.
        """
        model_service = _model_service(request)
        try:
            model_name = await model_service.save_trained_model(
                project_id, request.body
            )

            details = json.dumps({"info": "New model trained.", "model": model_name})
            updated_job = model_service.update_training_job(
                job.id, TrainingStatus.SUCCESS, details
            )

            telemetry.track(telemetry.MODEL_TRAINED_EVENT)

            nlg_service = NlgService.from_request(request)
            nlg_service.mark_responses_as_used(updated_job["started_at"])

            return (model_name, updated_job)

        except FileExistsError as e:
            logger.info(f"Nothing changed. You can use the old model stored at '{e}'.")
            details = json.dumps({"info": "Model already exists.", "path": str(e)})
            updated_job = model_service.update_training_job(
                job.id, TrainingStatus.SUCCESS, details
            )
            return (None, updated_job)

        except ValueError as e:
            logger.error(e)
            details = json.dumps({"reason": "ModelSaveFailed", "message": str(e)})
            updated_job = model_service.update_training_job(
                job.id, TrainingStatus.FAILURE, details
            )
            return (None, updated_job)

    def handle_training_errors(self, request: Request, job_id: Any,) -> Dict[Text, Any]:
        """Handles training error.

        Args:
            request: The incoming request.
            job_id: A model training job id.

        Returns:
            Updated `ModelTrainingJob`.
        """
        model_service = _model_service(request)
        rjs = request.json

        if rjs.get("reason") in ["TrainingError", "InvalidDomainError"]:
            reason = "TrainingError"
        else:
            reason = "UnexpectedError"

        details = json.dumps({"reason": reason, "message": rjs["message"]})
        updated_job = model_service.update_training_job(
            job_id, TrainingStatus.FAILURE, details
        )

        if rjs.get("reason") in ["TrainingError", "InvalidDomainError"]:
            total_training_time = updated_job["finished_at"] - updated_job["started_at"]
            telemetry.track_training_failed(rjs["version"], total_training_time)

        return updated_job

    def handle_non_training_errors(
        self, request: Request, job_id: int, error: Exception,
    ) -> Dict[Text, Any]:
        """Handles non training error.

        Args:
            request: The incoming request.
            job_id: A model training job id.
            error: An exception

        Returns:
            Updated `ModelTrainingJob`.
        """
        model_service = _model_service(request)
        logger.error(
            f"{error}\nEncountered an exception while training. "
            f"Please check the logs of the rasa worker container for more "
            f"information."
        )
        message = f"Failed to train a Rasa model. {error}"
        details = json.dumps({"reason": "UnexpectedError", "message": message})

        updated_job = model_service.update_training_job(
            job_id, TrainingStatus.FAILURE, details
        )
        return updated_job

    async def start_crossvalidating_nlu(
        self,
        insight_report_id: int,
        token: Text,
        team: Text = rasa_x_config.team_name,
        project_id: Text = rasa_x_config.project_name,
        self_url: Text = rasa_x_config.self_url,
        cross_validation_folds: int = 4,
    ) -> None:
        """Starts NLU cross validation.

        Calls the Rasa server to perform an NLU cross validation. Results are then
        posted to the given `api_url`.

        Args:
            insight_report_id: The ID of the nlu insight report that will be updated
                with the results.
            token: Used by the rasa server to post the evaluation results.
            team: User's team.
            project_id: The current project's ID
            self_url: The base URL for the callback endpoint that the results will be
                posted to.
            cross_validation_folds: Number of folds to use for the cross-validation.
        """
        from rasax.community.services.data_service import DataService

        url = "/model/test/intents"

        nlu_training_data = self.data_service.get_nlu_training_data_object(
            project_id=project_id, should_include_lookup_table_entries=True
        )
        nlu = DataService.training_data_to_dict(nlu_training_data)
        config = self.settings_service.get_config(team, project_id)

        # Combine everything into a single dict that will be converted to YAML
        contents = {**nlu, **config}

        request_url = self._request_url(url)
        logger.debug(f"Triggering cross validation at '{request_url}'.")

        async with self._session() as session:
            callback_url = (
                f"{self_url}/api/insights/nlu/{insight_report_id}/evaluation"
                f"?token={token}"
            )
            params = self._query_parameters(
                {
                    "callback_url": callback_url,
                    "cross_validation_folds": cross_validation_folds,
                }
            )
            response = await session.post(
                request_url,
                headers={"Content-Type": "application/x-yaml"},
                params=params,
                data=rasa.shared.utils.io.dump_obj_as_yaml_to_string(
                    contents, should_preserve_key_order=True
                ),
            )
            response.raise_for_status()
            return None

    async def evaluate_intents(
        self, training_examples: List[Dict[Text, Any]], model_path: Text
    ) -> Any:
        """Evaluates the intents."""
        from rasa.shared.nlu.training_data.formats.rasa import RasaReader
        from rasax.community.services import data_service

        training_data = RasaReader().read_from_json(
            data_service.nlu_format(training_examples)
        )
        nlu = data_service.DataService.training_data_to_dict(training_data)

        url = "/model/test/intents"

        async with self._session() as session:
            params = self._query_parameters({"model": model_path})
            response = await session.post(
                self._request_url(url),
                headers={"Content-Type": "application/x-yaml"},
                params=params,
                data=rasa.shared.utils.io.dump_obj_as_yaml_to_string(
                    nlu, should_preserve_key_order=True
                ),
            )
            return await response.json()

    async def predict_next_action(
        self, conversation_id: Text, included_events: Text = "ALL"
    ) -> Any:

        url = f"/conversations/{conversation_id}/predict"
        params = {INCLUDE_EVENTS_QUERY_PARAM: included_events}

        async with self._session() as session:
            response = await session.post(
                self._request_url(url), params=self._query_parameters(params)
            )
            return await response.json()

    @staticmethod
    def from_request(
        request: Request, project_id: Text, default_environment: Text
    ) -> "StackService":
        """Constructs Service object from the incoming request"""
        from rasax.community.services.settings_service import (  # noqa: E501
            SettingsService,
        )

        settings_service = SettingsService.from_request(request)

        environment = common_utils.deployment_environment_from_request(
            request, default_environment
        )
        service = settings_service.get_stack_service(environment, project_id)
        if not service:
            common_utils.error(
                HTTPStatus.NOT_FOUND,
                "ServiceNotFound",
                f"Service for requested environment '{environment}' not found.",
            )

        return service


async def collect_version_calls(
    environments: Dict[Text, StackService], timeout_in_seconds: Optional[float] = None
) -> Dict[Text, Union[Dict[Text, Text], Exception]]:
    """Collect the responses of the `/version` endpoint request each every environment.

    Args:
        environments: Mapping of environment names and their `StackService` instances.
        timeout_in_seconds: Timeout to use for the requests.

    Returns:
        Mapping of environment names and the responses of the `/version` request.
        Potential errors will be returned as if they would be regular values.
    """
    version_calls = [
        rasaService.version(timeout_in_seconds=timeout_in_seconds)
        for rasaService in environments.values()
    ]

    responses = await asyncio.gather(*version_calls, return_exceptions=True)
    return dict(zip(environments.keys(), responses))
