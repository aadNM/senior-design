import argparse
import asyncio
import logging
import os
import signal
from typing import Text, Union, Optional

from sqlalchemy.orm import Session

import rasax.server
import rasax.initialise
import rasax.community.config as rasa_x_config
import rasax.community.constants as constants
import rasax.community.jwt
from rasax.community.services.insights.insight_service import InsightService
import rasax.community.utils.config as config_utils
import rasax.community.utils.common as common_utils
import rasax.community.utils.cli as cli_utils
from rasax.community import telemetry, sql_migrations, scheduler, global_state
from rasax.community.database.utils import session_scope
from rasax.community.api.app import initialize_app
from rasax.community.services import model_service
from rasax.community.services.domain_service import DomainService
from rasax.community.services.license_service import LicenseService
from rasax.community.services.settings_service import (
    SettingsService,
    default_environments_config_local,
)

logger = logging.getLogger(__name__)

NUMBER_OF_SANIC_WORKERS = 1

LOCAL_DATA_DIR = "data"
LOCAL_DEFAULT_NLU_FILENAME = "nlu.yml"
LOCAL_DEFAULT_STORIES_FILENAME = "stories.yml"
LOCAL_DOMAIN_PATH = "domain.yml"
LOCAL_MODELS_DIR = "models"
LOCAL_RESULTS_DIR = "results"
LOCAL_ENDPOINTS_PATH = "endpoints.yml"


def _configure_for_local_server(
    data_path: Text, config_path: Text, token: Optional[Text] = None
) -> None:
    """Create `models` directory and set variables for local mode.

    Sets the API-wide token if provided.
    """

    if not os.path.isdir(LOCAL_MODELS_DIR):
        os.makedirs(LOCAL_MODELS_DIR)

    if token is not None:
        rasa_x_config.rasa_x_token = token

    rasa_x_config.data_dir = data_path
    rasa_x_config.rasa_model_dir = LOCAL_MODELS_DIR
    rasa_x_config.project_name = constants.COMMUNITY_PROJECT_NAME
    rasa_x_config.team_name = constants.COMMUNITY_TEAM_NAME
    rasa_x_config.data_dir = LOCAL_DATA_DIR
    rasa_x_config.default_nlu_filename = LOCAL_DEFAULT_NLU_FILENAME
    rasa_x_config.default_stories_filename = LOCAL_DEFAULT_STORIES_FILENAME
    rasa_x_config.default_username = constants.DEFAULT_USERNAME
    rasa_x_config.default_domain_path = LOCAL_DOMAIN_PATH
    rasa_x_config.default_config_path = config_path
    rasa_x_config.endpoints_path = LOCAL_ENDPOINTS_PATH


def check_license_and_telemetry(args: argparse.Namespace) -> None:
    """Ask the user to accept terms and conditions and initialize global variables.

    If already accepted, skip it. Also, prompt the user to set the telemetry settings.

    Args:
        args: Parsed command line arguments.
    """
    if not config_utils.are_terms_accepted():
        cli_utils.accept_terms_or_raise(args)

    telemetry.initialize_from_file(args.no_prompt)


def _event_service(endpoints_path: Text) -> None:
    """Start the event service."""
    # noinspection PyUnresolvedReferences
    from rasax.community.services import event_service

    # set endpoints path variable in this process
    rasa_x_config.endpoints_path = endpoints_path

    def signal_handler(sig, frame):
        logger.warning("Stopping event service.")
        os.kill(os.getpid(), signal.SIGTERM)

    signal.signal(signal.SIGINT, signal_handler)

    event_service.main(should_run_liveness_endpoint=False)


def _start_event_service() -> None:
    """Run the event service in a separate process."""

    common_utils.run_in_process(
        fn=_event_service, args=(LOCAL_ENDPOINTS_PATH,), daemon=True
    )


def _initialize_with_local_data(
    project_path: Text,
    data_path: Text,
    session: Session,
    rasa_port: Union[int, Text],
    config_path: Text,
    domain_path: Text,
) -> None:

    try:
        settings_service = SettingsService(session)
        default_env = default_environments_config_local(rasa_port)
        settings_service.save_environments(
            constants.COMMUNITY_PROJECT_NAME, default_env
        )

        loop = asyncio.get_event_loop()
        # inject data
        loop.run_until_complete(
            rasax.initialise.inject_files_from_disk(
                project_path,
                data_path,
                session,
                config_path=config_path,
                domain_path=domain_path,
                username=rasa_x_config.SYSTEM_USER,
            )
        )

        insight_service = InsightService(session)
        loop.run_until_complete(
            insight_service.start_nlu_insight_report_process(rasa_x_config.rasa_x_token)
        )

        # dump domain once
        domain_service = DomainService(session)
        domain_service.dump_domain(rasa_x_config.project_name)

    except rasax.initialise.InjectionError as e:
        logger.debug(f"An error happened when injecting the local project: {e}")
        cli_utils.print_error_and_exit(str(e))


def main(
    args: argparse.Namespace,
    project_path: Text,
    data_path: Text,
    token: Optional[Text] = None,
    config_path: Optional[Text] = None,
    domain_path: Optional[Text] = None,
) -> None:
    """Start Rasa X in local mode.

    Args:
        args: The parsed command line arguments which were passed to `rasa x`.
        project_path: The path to the Rasa Open Source project which includes training
            data and others.
        data_path: The path to the training data within `project_path`.
        token: The token which will be used by Rasa Open Source to authenticate
            against the Rasa X API.
        config_path: The path to the `config.yml` within the `project_path`.
        domain_path: The path to the domain file/folder within the `project_path`.
    """
    # Initialize the global state before doing anything else.
    # This will set config.LOCAL_MODE to True!
    global_state.initialize_global_state(NUMBER_OF_SANIC_WORKERS, is_local_mode=True)

    # Make sure the user has agreed to the Rasa X license.
    check_license_and_telemetry(args)

    if config_path is None:
        config_path = rasa_x_config.default_config_path

    if not domain_path:
        domain_path = rasa_x_config.default_domain_path

    rasa_x_config.self_port = args.rasa_x_port

    _configure_for_local_server(data_path, config_path, token)

    rasax.community.jwt.initialise_jwt_keys()

    app = rasax.server.configure_app()

    with session_scope() as session:
        cli_utils.print_success("Preparing the local database...")

        sql_migrations.run_migrations(session)
        edition = (
            "Enterprise" if LicenseService.is_enterprise_activated(session) else "X"
        )

        cli_utils.print_success(f"Starting Rasa {edition} in local mode... ðŸš€")

        auth_endpoints = rasax.server.additional_auth_endpoints()
        initialize_app(app, class_views=auth_endpoints)

        user, password = rasax.initialise.setup_initial_admin_user(session, create=True)
        common_utils.run_operation_in_single_sanic_worker(
            app, rasax.initialise.AppStartedCallable(user, password)
        )

        rasax.server.log_license_information(session)

        _initialize_with_local_data(
            project_path, data_path, session, args.port, config_path, domain_path
        )

        telemetry.track(telemetry.LOCAL_START_EVENT)
        telemetry.track_project_status(session)

    # this needs to run after initial database structures are created
    # otherwise projects assigned to events won't be present
    _start_event_service()

    scheduler.start_background_scheduler()

    # Run models discovery
    common_utils.run_in_loop(model_service.discover_models())

    app.run(
        host="0.0.0.0",
        port=rasa_x_config.self_port,
        auto_reload=os.environ.get("SANIC_AUTO_RELOAD"),
        access_log=False,
        workers=NUMBER_OF_SANIC_WORKERS,
    )
