import logging
import os
from pathlib import Path
import sqlalchemy.orm as orm
import typing
from typing import Text, Tuple, Generator, Dict, List, Set, Any, Optional, Union

import sqlalchemy.orm
import rasa.shared.data
from rasa.shared.core.domain import InvalidDomain
from rasa.shared.exceptions import YamlException

import rasax.community.constants as constants
import rasax.community.config as rasa_x_config
import rasax.community.utils.cli as cli_utils
import rasax.community.utils.config as config_utils
import rasax.community.utils.io as io_utils
import rasax.community.utils.yaml as yaml_utils
import rasax.community.utils.common as common_utils
from rasax.community.services.domain_service import DomainService
from rasax.community.services.story_service import StoryService
from rasax.community.services.user_service import (
    UserService,
    UserException,
    RoleException,
    AuthMechanisms,
    ADMIN,
)
from rasax.community.services.license_service import LicenseService

if typing.TYPE_CHECKING:
    from rasax.community.services.settings_service import SettingsService
    from rasax.community.services.data_service import DataService
    from rasax.community.services.nlg_service import NlgService

logger = logging.getLogger(__name__)


class InjectionError(Exception):
    """Error when something went wrong while injecting files into Rasa X."""


def create_user(
    service: UserService, username: Text, password: Text, role: Text, team: Text,
) -> None:
    """Create a user with specified parameters.

    Arguments:
        service: An instance of the `rasax.community.services.user_service.UserService`.
        username: A username for the user.
        password: A password for the user.
        role: A role for the user (must be either "admin", "annotator", "tester", or "guest").
        team: A valid team name for the user.
    """
    try:
        service.create_user(
            username, password, team, role, AuthMechanisms.username_password,
        )
    except UserException as e:
        cli_utils.print_error_and_exit(
            f"User '{e}' already exists. You can update the password by "
            f"running `sudo python rasa_x_commands.py create --update "
            f"admin {e} <new_pw>`"
        )
    except RoleException:
        cli_utils.print_error_and_exit(
            f"Role '{role}' does not exist. Please select a valid role."
        )


def _read_password() -> Optional[Text]:
    password = os.getenv(constants.ENV_RASA_X_PASSWORD)

    if not password and (
        rasa_x_config.LOCAL_MODE or not LicenseService.is_enterprise_activated()
    ):
        # Generate a password instead when either:
        # - Enterprise is not activated.
        # - We are running on Local mode.
        password = common_utils.random_password()

    return password


def setup_initial_admin_user(
    session: sqlalchemy.orm.Session, create: bool
) -> Tuple[Optional[Text], Optional[Text]]:
    """Setup the initial administrator user for this server.

    The initial administrator user will only be created if `create` is
    `True`. How the passoword is set depends on whether we are running on Local
    or Server mode, and if Enterprise is activated or not.

    This function is a merging of the old "community" and Enterprise
    initialisation functions. It is also used for Local mode initialisation.

    Args:
        session: SQLAlchemy session.
        create: Whether we should attempt to create the administrator user.

    Returns:
        See return value of `_set_initial_admin_user_password`.
    """
    user_service = UserService(session)
    username = os.getenv(constants.ENV_RASA_X_USERNAME, constants.DEFAULT_USERNAME,)

    # First, if required, create the user
    if create:
        try:
            user = user_service.create_user(
                username=username,
                raw_password=None,
                team=rasa_x_config.team_name,
                roles=ADMIN,
                auth_mechanism=AuthMechanisms.username_password,
            )
            if user:
                cli_utils.print_info(
                    f"Created initial administrator user '{username}'."
                )
        except UserException:
            logger.debug(
                f"Skip creating initial admin user '{username}', as it already exists."
            )

    # Second, decide if we set or update its password or not
    return _set_initial_admin_user_password(user_service, username)


def _set_initial_admin_user_password(
    user_service: UserService, username: Text
) -> Tuple[Optional[Text], Optional[Text]]:
    """Set the initial administrator user's password if possible.

    Args:
        user_service: `UserService` with a session attached to it.
        username: The administrator user's username.

    Returns:
        Tuple of optional username and password. The username will only be
        returned if the initial administrator user exists (even if it was
        created outside this function). The password will only be returned if
        it was set during the call to this function.
    """
    if not user_service.fetch_user(username):
        return None, None

    password = None

    if rasa_x_config.LOCAL_MODE:
        # Local mode: always overwrite password with a new one.
        password = _read_password()
        user_service.insert_or_update_user(username, password, rasa_x_config.team_name)
    elif user_service.is_user_password_set_required(username):
        # Server mode (only when admin user has no password).
        password = _read_password()
        if password:
            user_service.insert_or_update_user(
                username, password, rasa_x_config.team_name
            )
        else:
            cli_utils.print_warning(
                f"No password set for user '{username}'. Make sure you have specified "
                f"the '{constants.ENV_RASA_X_PASSWORD}' environment "
                f"variable."
            )

    return username, password


def inject_config(
    config_path: Text, settings_service: "SettingsService"
) -> Union[List[Any], Dict[Text, Any]]:
    """Load a configuration file from `path` and save it to the database.

    Quits the application if config cannot be loaded.
    """
    if not os.path.exists(config_path):
        raise InjectionError(
            f"Failed to inject Rasa configuration. The file "
            f"'{os.path.abspath(config_path)}' does not exist."
        )

    _config = yaml_utils.read_yaml_file(config_path)
    if not _config:
        raise InjectionError(
            f"Failed to inject Rasa configuration:\n"
            f"Reading of yaml '{os.path.abspath(config_path)}' file failed. Most "
            f"likely the file was not found or uses the wrong syntax."
        )

    settings_service.save_config(
        rasa_x_config.team_name, "default", _config, config_path, should_dump=False,
    )

    logger.debug(
        "Loaded local configuration from '{}' into database".format(
            os.path.abspath(config_path)
        )
    )
    return _config


def _read_data(paths: List[Text]) -> Generator[Tuple[Text, Text], None, None]:
    for filename in paths:
        try:
            yield io_utils.read_file(filename), filename
        except ValueError:
            cli_utils.print_warning(f"Cannot read file {filename}")


def inject_nlu_data(
    nlu_files: Union[List[Text], Set[Text]],
    project_id: Text,
    username: Text,
    data_service: "DataService",
    nlg_service: "NlgService",
) -> None:
    """Load Rasa NLU training data from `path` and save it to the database.

    Args:
        nlu_files: NLU files the data from which needs to be saved.
        project_id: ID of the project.
        username: Name of the user.
        data_service: Service to obtain the current NLU training data.
        nlg_service: Service to manipulate NLG data.
    """
    # delete existing data in db if files are provided
    if nlu_files:
        data_service.delete_data()
        data_service.delete_additional_training_features(project_id)

        nlg_service.delete_all_responses(True)

    training_examples_count = data_service.save_bulk_data_from_files(
        nlu_files, project_id, username
    )

    logger.debug(f"Injected {training_examples_count} NLU training data examples.")


async def inject_stories(
    story_files: Union[List[Text], Set[Text]],
    test_story_files: Union[List[Text], Set[Text]],
    story_service: "StoryService",
    team: Text,
    project_id: Text,
    username: Text,
) -> None:
    """Load Core stories from `data_directory` and save to the database.

    Args:
        story_files: A set of files that contain stories.
        test_story_files: A set of files that contain test stories.
        story_service: Service to obtain the Rasa Core stories training data.
        team: Users' team.
        project_id: ID of the project.
        username: Name of the user.
    """
    story_blocks = []
    test_story_blocks = []

    if story_files:
        # delete existing stories in db if files are provided
        story_service.delete_all_stories(delete_test_stories=False)

        # store provided stories in db
        story_blocks = await story_service.save_stories_from_files(
            story_files, team, project_id, username
        )

    if test_story_files:
        # delete existing test stories in db if files are provided
        story_service.delete_all_stories(delete_test_stories=True)

        # store provided test stories in db
        test_story_blocks = await story_service.save_stories_from_files(
            test_story_files, team, project_id, username, is_test=True
        )

    logger.debug(f"Injected {len(story_blocks)} Core stories.")
    logger.debug(f"Injected {len(test_story_blocks)} test stories.")


def inject_domain(
    domain_path: Path, domain_service: "DomainService", project_id: Text, username: Text
) -> None:
    """Load Rasa Core domain at `path` and save it to database.

    Quits the application if domain cannot be loaded.
    """
    domain_service.delete_all_domains()

    if not domain_path.exists():
        raise InjectionError(
            f"Domain could not be found at '{domain_path.absolute()}'. "
            f"Rasa X requires a domain file/folder in the project root directory."
        )

    domain_files = []
    if domain_path.is_file():
        domain_files.append(domain_path)
    else:
        for potential_domain in domain_path.rglob("[!.]*"):
            # Ignore the `data` folder to avoid issues with NLU `responses`.
            # This is a temporary solution caused by the fact that Rasa X
            # cannot treat the same file as both: nlu and domain.
            # TODO: Fix this issue.
            # Also ignores any hidden files and directories.
            if any(
                (
                    p.resolve()
                    == (
                        io_utils.get_project_directory()
                        / constants.DEFAULT_RASA_DATA_PATH
                    ).resolve()
                    for p in Path(potential_domain).parents
                )
            ) or any(
                str(p.resolve()).startswith(
                    str(io_utils.get_project_directory().resolve())
                )
                and p.name.startswith(".")
                for p in Path(potential_domain).parents
            ):
                continue

            if not rasa.shared.core.domain.Domain.is_domain_file(
                str(potential_domain.absolute())
            ):
                continue
            domain_files.append(potential_domain)

    for domain_file in sorted(domain_files):
        try:
            domain_service.validate_and_store_domain_yaml(
                domain_yaml=io_utils.read_file(domain_file),
                project_id=project_id,
                username=username,
                filename=str(domain_file.resolve()),
                store_responses=True,
                should_dump_domain=False,
                overwrite=True,
            )

        except (InvalidDomain, YamlException) as e:
            raise InjectionError(f"Could not inject domain. Details:\n{e}")


class AppStartedCallable:
    """A class that represents a callable that is called after the start of the application."""

    def __init__(self, user: Optional[Text], password: Optional[Text]) -> None:
        """The constructor for the AppStartedCallable.

        Args:
            user: Initial user's username.
            password: The password for the initial user.
        """
        self.user = user
        self.password = password

    @staticmethod
    def open_web_browser(login_url: Text) -> None:
        """Opens a new tab on the user's preferred web browser and points it to `login_url`.

        Depending on the telemetry configuration, a separate tab may be opened as well,
        showing the user a welcome page.

        Args:
            login_url: URL which the tab should be pointed at.
        """
        import webbrowser

        telemetry_config = config_utils.read_global_config_value(
            constants.CONFIG_FILE_TELEMETRY_KEY
        )

        if telemetry_config and telemetry_config[constants.CONFIG_TELEMETRY_ENABLED]:
            # If the telemetry config does not contain CONFIG_TELEMETRY_WELCOME_SHOWN,
            # then the user has upgraded from a previous version of Rasa X (before
            # this config value was introduced). In these cases, assume that the
            # user has already seen the welcome page.
            if not telemetry_config.get(constants.CONFIG_TELEMETRY_WELCOME_SHOWN, True):
                webbrowser.open_new_tab(constants.WELCOME_PAGE_URL)

            telemetry_config[constants.CONFIG_TELEMETRY_WELCOME_SHOWN] = True
            config_utils.write_global_config_value(
                constants.CONFIG_FILE_TELEMETRY_KEY, telemetry_config
            )

        webbrowser.open_new_tab(login_url)

    def __call__(self) -> None:
        """Execute a set of actions that should be executed after start."""
        server_url = f"http://localhost:{rasa_x_config.self_port}"
        login_url = f"{server_url}/login"
        if self.user and self.password:
            login_url += f"?username={self.user}&password={self.password}"

        cli_utils.print_success(f"\nThe server is running at {login_url}\n")

        if rasa_x_config.OPEN_WEB_BROWSER:
            AppStartedCallable.open_web_browser(login_url)


async def inject_files_from_disk(
    project_path: Union[Path, Text],
    data_path: Text,
    session: orm.Session,
    domain_path: Text,
    config_path: Optional[Text],
    username: Text,
) -> None:
    """Injects local files into database.

    Args:
        project_path: Path to the project of which the data should be injected.
        data_path: Path to the data within this project.
        session: Database session.
        domain_path: Path to the domain file/folder to be injected.
        username: The username which is used to inject the data.
        config_path: Path to the config file within the project

    Raises:
        InjectionError: If anything goes wrong while injecting the data from the files.
    """
    from rasax.community.services.data_service import DataService
    from rasax.community.services.nlg_service import NlgService
    from rasax.community.services.settings_service import SettingsService

    io_utils.set_project_directory(project_path)
    if Path(domain_path).resolve() != Path(project_path).resolve():
        domain_path = Path(project_path) / domain_path

    domain_service = DomainService(session)
    inject_domain(
        Path(domain_path), domain_service, constants.COMMUNITY_PROJECT_NAME, username,
    )

    settings_service = SettingsService(session)
    inject_config(os.path.join(project_path, config_path), settings_service)

    nlu_files = rasa.shared.data.get_data_files(data_path, rasa.shared.data.is_nlu_file)
    story_files = rasa.shared.data.get_data_files(
        data_path, rasa.shared.data.is_story_file
    )
    test_story_files = rasa.shared.data.get_data_files(
        str(Path(project_path) / rasa_x_config.default_test_stories_dir),
        rasa.shared.data.is_test_stories_file,
    )

    story_service = StoryService(session)
    await inject_stories(
        story_files,
        test_story_files,
        story_service,
        constants.COMMUNITY_TEAM_NAME,
        constants.COMMUNITY_PROJECT_NAME,
        username,
    )

    data_service = DataService(session)
    nlg_service = NlgService(session)
    inject_nlu_data(
        nlu_files, constants.COMMUNITY_PROJECT_NAME, username, data_service, nlg_service
    )
